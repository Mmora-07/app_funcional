# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o1TrU9eNzLn1FQvgyajbnLjJ5SE3vDat
"""

import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
import json
from pathlib import Path

# --- 1. DEFINICI√ìN DE LA ARQUITECTURA DEL MODELO ---
# La arquitectura del modelo es correcta y no necesita cambios.
class RiskNN(nn.Module):
    def __init__(self, num_features, cat_dims, emb_dims, hidden, dropout):
        super().__init__()
        self.emb = nn.ModuleList([
            nn.Embedding(dim, emb) for dim, emb in zip(cat_dims, emb_dims)
        ])

        layer_list = []
        current_dim = num_features + sum(emb_dims)

        for hidden_size in hidden:
            layer_list.append(nn.Linear(current_dim, hidden_size))
            layer_list.append(nn.BatchNorm1d(hidden_size))
            layer_list.append(nn.GELU())
            layer_list.append(nn.Dropout(dropout))
            current_dim = hidden_size

        layer_list.append(nn.Linear(current_dim, 1))
        self.net = nn.Sequential(*layer_list)

    def forward(self, x_num, x_cat):
        # El error de √≠ndice ocurre aqu√≠ si los √≠ndices en x_cat
        # son mayores que los `cat_dims` con los que se entren√≥ el modelo.
        emb = [m(x_cat[:, i]) for i, m in enumerate(self.emb)]
        x = torch.cat(emb + [x_num], dim=1)
        return self.net(x).squeeze(1)

# --- 2. FUNCI√ìN PARA CARGAR EL MODELO (EN CACH√â) ---
@st.cache_resource
def load_model_and_artifacts():
    """Carga el modelo, metadatos y estad√≠sticas de normalizaci√≥n."""
    base_path = Path(__file__).parent
    model_dir = base_path / "modeloFinal"

    with open(model_dir / "model_metadata.json", 'r') as f:
        metadata = json.load(f)

    model = RiskNN(
        num_features=metadata['num_features'],
        cat_dims=metadata['cat_dims'],
        emb_dims=metadata['emb_dims'],
        hidden=metadata['hidden_layers'],
        dropout=metadata['dropout'],
    )

    model.load_state_dict(torch.load(model_dir / "best_model_final.pth", map_location=torch.device("cpu"), weights_only=True))
    model.eval()

    norm_stats = {
        'means': pd.Series({
            'loan_amnt': 14755.26, 'annual_inc': 75035.56, 'dti': 18.14, 'revol_util': 55.0,
            'total_acc': 25.41, 'tot_cur_bal': 139474.49, 'days_since_earliest_cr': 5851.05
        }),
        'stds': pd.Series({
            'loan_amnt': 8435.46, 'annual_inc': 64149.29, 'dti': 8.37, 'revol_util': 24.5,
            'total_acc': 11.84, 'tot_cur_bal': 153749.12, 'days_since_earliest_cr': 2724.08
        })
    }

    return model, metadata, norm_stats

# --- 3. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(page_title="Evaluador de Riesgo Crediticio NN", page_icon="ü§ñ", layout="centered")
st.title("ü§ñ Evaluador de Riesgo Crediticio (Red Neuronal)")
st.markdown("Ingrese los datos del solicitante para obtener una predicci√≥n de riesgo.")
st.markdown("---")

# --- 4. CARGAR MODELO ---
try:
    nn_model, metadata, norm_stats = load_model_and_artifacts()
    st.success("Modelo de Red Neuronal cargado exitosamente.")
except Exception as e:
    st.error(f"Error al cargar el modelo: {e}")
    st.stop()

# --- 5. FORMULARIO DE ENTRADA (CON OPCIONES COMPLETAS) ---
with st.form("formulario_riesgo_nn"):
    st.subheader("üìã Datos del Solicitante")

    col1, col2 = st.columns(2)
    with col1:
        loan_amnt = st.number_input("üí∞ Monto del Pr√©stamo ($)", min_value=1000.0, value=15000.0, step=500.0)
        annual_inc = st.number_input("üìà Ingreso Anual ($)", min_value=10000.0, value=75000.0, step=1000.0)
        dti = st.number_input("üìä Ratio Deuda/Ingreso (DTI)", min_value=0.0, value=18.0, step=0.1)
        revol_util = st.number_input("üìâ Uso de Cr√©dito Revolvente (%)", min_value=0.0, max_value=100.0, value=55.0, step=0.1)

    with col2:
        total_acc = st.number_input("üìÇ Cuentas de Cr√©dito Totales", min_value=0, value=25)
        tot_cur_bal = st.number_input("üíº Saldo Corriente Total ($)", min_value=0.0, value=140000.0, step=1000.0)
        days_since_earliest_cr = st.number_input("‚è≥ Antig√ºedad Crediticia (d√≠as)", min_value=365, value=5800)

    st.markdown("---")

    # Definimos las opciones para los campos categ√≥ricos tal como aparecen en la UI
    emp_length_options = ['< 1 year', '1 year', '2 years', '3 years', '4 years', '5 years', '6 years', '7 years', '8 years', '9 years', '10+ years']
    home_ownership_options = ['RENT', 'OWN', 'MORTGAGE', 'OTHER']
    purpose_options = ['debt_consolidation', 'credit_card', 'home_improvement', 'other', 'major_purchase']
    delinq_2yrs_options = ['0', '1', '>=2']
    inq_last_6mths_options = ['0', '1', '>=2']
    pub_rec_options = ['0', '1']

    col3, col4 = st.columns(2)
    with col3:
        emp_length = st.selectbox("üìÜ Antig√ºedad Laboral", options=emp_length_options, index=10)
        home_ownership = st.selectbox("üè† Tipo de Vivienda", options=home_ownership_options, index=2)
        purpose = st.selectbox("üéØ Prop√≥sito del Pr√©stamo", options=purpose_options, index=0)

    with col4:
        delinq_2yrs = st.selectbox("‚ùå Morosidades (√∫ltimos 2 a√±os)", options=delinq_2yrs_options, index=0)
        inq_last_6mths = st.selectbox("üìå Solicitudes de Cr√©dito (√∫ltimos 6 meses)", options=inq_last_6mths_options, index=1)
        pub_rec = st.selectbox("‚öñÔ∏è Registros P√∫blicos Negativos", options=pub_rec_options, index=0)

    enviado = st.form_submit_button("Evaluar Riesgo")

# --- 6. PROCESAMIENTO Y PREDICCI√ìN ---
if enviado:
    # ***** INICIO DE LA CORRECCI√ìN *****
    # El script de entrenamiento (`train.py`) usa `pandas.astype('category').cat.categories`,
    # que ordena alfab√©ticamente las categor√≠as para asignarles un √≠ndice.
    # Debemos replicar ese mismo comportamiento aqu√≠ para ser consistentes.

    # Se crean los mapeos para cada variable categ√≥rica usando una lista ORDENADA ALFAB√âTICAMENTE.
    cat_map_corrected = {
        'emp_length': {val: i for i, val in enumerate(sorted(emp_length_options))},
        'home_ownership': {val: i for i, val in enumerate(sorted(home_ownership_options))},
        'purpose': {val: i for i, val in enumerate(sorted(purpose_options))},
        'delinq_2yrs': {val: i for i, val in enumerate(sorted(delinq_2yrs_options))},
        'inq_last_6mths': {val: i for i, val in enumerate(sorted(inq_last_6mths_options))},
        'pub_rec': {val: i for i, val in enumerate(sorted(pub_rec_options))}
    }

    # Usamos el mapeo corregido para convertir el input del usuario al √≠ndice correcto.
    # El orden de las variables aqu√≠ DEBE COINCIDIR con el orden de las columnas en el entrenamiento.
    # Asumimos que este orden es correcto.
    try:
        cat_inputs = [
            cat_map_corrected['emp_length'][emp_length],
            cat_map_corrected['home_ownership'][home_ownership],
            cat_map_corrected['purpose'][purpose],
            cat_map_corrected['delinq_2yrs'][delinq_2yrs],
            cat_map_corrected['inq_last_6mths'][inq_last_6mths],
            cat_map_corrected['pub_rec'][pub_rec]
        ]
        tensor_cat = torch.tensor([cat_inputs], dtype=torch.long)
    except KeyError as e:
        st.error(f"Error de mapeo: la categor√≠a '{e.args[0]}' no fue encontrada. Revisa las opciones.")
        st.stop()

    # ***** FIN DE LA CORRECCI√ìN *****

    # Procesamiento de Variables Num√©ricas
    num_inputs_df = pd.DataFrame([[
        loan_amnt, annual_inc, dti, revol_util, total_acc, tot_cur_bal, days_since_earliest_cr
    ]], columns=list(norm_stats['means'].index))

    num_inputs_normalized = (num_inputs_df - norm_stats['means']) / norm_stats['stds']

    # NOTA: La siguiente l√≠nea inserta una columna de ceros. Esto sugiere que el modelo
    # fue entrenado con una variable num√©rica m√°s de las que se piden en el formulario.
    # Se mantiene por consistencia, pero ser√≠a bueno revisarlo.
    num_inputs_final = np.insert(num_inputs_normalized.values, 0, 0, axis=1)
    tensor_num = torch.tensor(num_inputs_final, dtype=torch.float32)

    # Realizar la Predicci√≥n
    with torch.no_grad():
        logits = nn_model(tensor_num, tensor_cat)
        probability = torch.sigmoid(logits).item()

    # Mostrar el Resultado
    st.markdown("---")
    prob_percent = probability * 100

    st.subheader("Resultado de la Evaluaci√≥n")
    if probability > 0.5:
        st.error(f"üî¥ Riesgo Alto (Probabilidad de Incumplimiento: {prob_percent:.2f}%)")
        st.warning("Recomendaci√≥n: Es probable que el cr√©dito sea rechazado.")
    else:
        st.success(f"üü¢ Riesgo Bajo (Probabilidad de Incumplimiento: {prob_percent:.2f}%)")
        st.info("Recomendaci√≥n: Es probable que el cr√©dito sea aprobado.")
        st.balloons()

    st.progress(probability)

    with st.expander("Ver detalles t√©cnicos de la predicci√≥n"):
        st.write(f"**Logit del modelo (salida cruda):** `{logits.item():.4f}`")
        st.write(f"**Probabilidad (Sigmoid):** `{probability:.4f}`")
        st.write("**Tensor de entrada categ√≥rico (√≠ndices):**")
        st.write(tensor_cat)
        st.write("**Mapeo de antig√ºedad laboral usado (Alfab√©tico):**")
        st.json(cat_map_corrected['emp_length'])