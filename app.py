# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o1TrU9eNzLn1FQvgyajbnLjJ5SE3vDat
"""

import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
import json
from pathlib import Path

# --- 1. DEFINICI√ìN DE LA ARQUITECTURA DEL MODELO ---
# La arquitectura del modelo es correcta y no necesita cambios.
class RiskNN(nn.Module):
    def __init__(self, num_features, cat_dims, emb_dims, hidden, dropout):
        super().__init__()
        self.emb = nn.ModuleList([
            nn.Embedding(dim, emb) for dim, emb in zip(cat_dims, emb_dims)
        ])

        layer_list = []
        current_dim = num_features + sum(emb_dims)

        for hidden_size in hidden:
            layer_list.append(nn.Linear(current_dim, hidden_size))
            layer_list.append(nn.BatchNorm1d(hidden_size))
            layer_list.append(nn.GELU())
            layer_list.append(nn.Dropout(dropout))
            current_dim = hidden_size

        layer_list.append(nn.Linear(current_dim, 1))
        self.net = nn.Sequential(*layer_list)

    def forward(self, x_num, x_cat):
        emb = [m(x_cat[:, i]) for i, m in enumerate(self.emb)]
        x = torch.cat(emb + [x_num], dim=1)
        return self.net(x).squeeze(1)

# --- 2. FUNCI√ìN PARA CARGAR EL MODELO (EN CACH√â) ---
@st.cache_resource
def load_model_and_artifacts():
    """Carga el modelo, metadatos y estad√≠sticas de normalizaci√≥n."""
    base_path = Path(__file__).parent
    model_dir = base_path / "modeloFinal"

    with open(model_dir / "model_metadata.json", 'r') as f:
        metadata = json.load(f)

    model = RiskNN(
        num_features=metadata['num_features'],
        cat_dims=metadata['cat_dims'],
        emb_dims=metadata['emb_dims'],
        hidden=metadata['hidden_layers'],
        dropout=metadata['dropout'],
    )

    model.load_state_dict(torch.load(model_dir / "best_model_final.pth", map_location=torch.device("cpu"), weights_only=True))
    model.eval()

    norm_stats = {
        'means': pd.Series({
            'loan_amnt': 14755.26, 'annual_inc': 75035.56, 'dti': 18.14, 'revol_util': 55.0,
            'total_acc': 25.41, 'tot_cur_bal': 139474.49, 'days_since_earliest_cr': 5851.05
        }),
        'stds': pd.Series({
            'loan_amnt': 8435.46, 'annual_inc': 64149.29, 'dti': 8.37, 'revol_util': 24.5,
            'total_acc': 11.84, 'tot_cur_bal': 153749.12, 'days_since_earliest_cr': 2724.08
        })
    }

    return model, metadata, norm_stats

# --- 3. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(page_title="Evaluador de Riesgo Crediticio NN", page_icon="ü§ñ", layout="centered")
st.title("ü§ñ Evaluador de Riesgo Crediticio ")
st.markdown("Ingrese los datos del solicitante para obtener una predicci√≥n de riesgo.")
st.markdown("---")

# --- 4. CARGAR MODELO ---
try:
    nn_model, metadata, norm_stats = load_model_and_artifacts()
    st.success("Modelo de Red Neuronal cargado exitosamente.")
except Exception as e:
    st.error(f"Error al cargar el modelo: {e}")
    st.stop()

# --- 5. FORMULARIO DE ENTRADA (CON OPCIONES ORIGINALES) ---
with st.form("formulario_riesgo_nn"):
    st.subheader("üìã Datos del Solicitante")

    col1, col2 = st.columns(2)
    with col1:
        loan_amnt = st.number_input("üí∞ Monto del Pr√©stamo ($)", min_value=1000.0, value=15000.0, step=500.0)
        annual_inc = st.number_input("üìà Ingreso Anual ($)", min_value=10000.0, value=75000.0, step=1000.0)
        dti = st.number_input("üìä Ratio Deuda/Ingreso (DTI)", min_value=0.0, value=18.0, step=0.1)
        revol_util = st.number_input("üìâ Uso de Cr√©dito Revolvente (%)", min_value=0.0, max_value=100.0, value=55.0, step=0.1)

    with col2:
        total_acc = st.number_input("üìÇ Cuentas de Cr√©dito Totales", min_value=0, value=25)
        tot_cur_bal = st.number_input("üíº Saldo Corriente Total ($)", min_value=0.0, value=140000.0, step=1000.0)
        days_since_earliest_cr = st.number_input("‚è≥ Antig√ºedad Crediticia (d√≠as)", min_value=365, value=5800)

    st.markdown("---")

    # Opciones que ve el usuario (ANTES de la transformaci√≥n de EDA)
    emp_length_options = ['< 1 year', '1 year', '2 years', '3 years', '4 years', '5 years', '6 years', '7 years', '8 years', '9 years', '10+ years']
    home_ownership_options = ['RENT', 'OWN', 'MORTGAGE', 'OTHER', 'ANY', 'NONE']
    purpose_options = [
        'debt_consolidation', 'credit_card', 'home_improvement', 'other', 'major_purchase', 'car',
        'house', 'vacation', 'wedding', 'moving', 'medical', 'educational', 'small_business', 'renewable_energy'
    ]
    delinq_2yrs_options = ['0', '1', '>=2']
    inq_last_6mths_options = ['0', '1', '>=2'] # Esta no se transforma en la EDA
    pub_rec_options = ['0', '1', '>=2']

    col3, col4 = st.columns(2)
    with col3:
        emp_length = st.selectbox("üìÜ Antig√ºedad Laboral", options=emp_length_options, index=10)
        home_ownership = st.selectbox("üè† Tipo de Vivienda", options=home_ownership_options, index=2)
        purpose = st.selectbox("üéØ Prop√≥sito del Pr√©stamo", options=purpose_options, index=0)

    with col4:
        delinq_2yrs = st.selectbox("‚ùå Morosidades (√∫ltimos 2 a√±os)", options=delinq_2yrs_options, index=0)
        inq_last_6mths = st.selectbox("üìå Solicitudes de Cr√©dito (√∫ltimos 6 meses)", options=inq_last_6mths_options, index=1)
        pub_rec = st.selectbox("‚öñÔ∏è Registros P√∫blicos Negativos", options=pub_rec_options, index=0)

    enviado = st.form_submit_button("Evaluar Riesgo")

# --- 6. PROCESAMIENTO Y PREDICCI√ìN (CON L√ìGICA DE EDA) ---
if enviado:
    # ***** INICIO DE LA CORRECCI√ìN: APLICAR TRANSFORMACIONES DE EDA *****

    # 1. Transformar las entradas del usuario seg√∫n las reglas del notebook

    # -- emp_length --
    if emp_length in ['5 years', '6 years', '7 years', '8 years', '9 years', '10+ years']:
        processed_emp_length = '5+ years'
    else:
        processed_emp_length = emp_length

    # -- home_ownership --
    if home_ownership in ['ANY', 'NONE']:
        processed_home_ownership = 'OTHER'
    else:
        processed_home_ownership = home_ownership

    # -- purpose --
    purpose_mapping_eda = {
        'debt_consolidation': 'debt_consolidation', 'credit_card': 'credit_related', 'major_purchase': 'credit_related',
        'car': 'credit_related', 'home_improvement': 'credit_related', 'house': 'credit_related', 'vacation': 'personal_expenses',
        'wedding': 'personal_expenses', 'moving': 'personal_expenses', 'medical': 'personal_expenses',
        'educational': 'personal_expenses', 'small_business': 'small_business', 'renewable_energy': 'other', 'other': 'other'
    }
    processed_purpose = purpose_mapping_eda.get(purpose, 'other')

    # -- delinq_2yrs --
    if delinq_2yrs in ['1', '>=2']:
        processed_delinq_2yrs = '>=1'
    else:
        processed_delinq_2yrs = '0'

    # -- pub_rec --
    if pub_rec in ['1', '>=2']:
        processed_pub_rec = '>=1'
    else:
        processed_pub_rec = '0'

    # -- inq_last_6mths no cambia --
    processed_inq_last_6mths = inq_last_6mths

    # 2. Crear los mapeos a √≠ndices basados en las categor√≠as FINALES (post-EDA), ordenadas alfab√©ticamente.
    final_cat_options = {
        'emp_length': sorted(['< 1 year', '1 year', '2 years', '3 years', '4 years', '5+ years']),
        'home_ownership': sorted(['RENT', 'OWN', 'MORTGAGE', 'OTHER']),
        'purpose': sorted(list(set(purpose_mapping_eda.values()))), # Obtener categor√≠as √∫nicas
        'delinq_2yrs': sorted(['0', '>=1']),
        'inq_last_6mths': sorted(['0', '1', '>=2']), # Opciones originales
        'pub_rec': sorted(['0', '>=1'])
    }

    final_cat_maps = {
        key: {val: i for i, val in enumerate(options)}
        for key, options in final_cat_options.items()
    }

    # 3. Convertir las variables procesadas a sus √≠ndices num√©ricos
    try:
        cat_inputs = [
            final_cat_maps['emp_length'][processed_emp_length],
            final_cat_maps['home_ownership'][processed_home_ownership],
            final_cat_maps['purpose'][processed_purpose],
            final_cat_maps['delinq_2yrs'][processed_delinq_2yrs],
            final_cat_maps['inq_last_6mths'][processed_inq_last_6mths],
            final_cat_maps['pub_rec'][processed_pub_rec]
        ]
        tensor_cat = torch.tensor([cat_inputs], dtype=torch.long)
    except KeyError as e:
        st.error(f"Error de mapeo final: la categor√≠a procesada '{e.args[0]}' no se encontr√≥. Revisa la l√≥gica de EDA.")
        st.stop()

    # ***** FIN DE LA CORRECCI√ìN *****

    # Procesamiento de Variables Num√©ricas (se mantiene igual)
    num_inputs_df = pd.DataFrame([[
        loan_amnt, annual_inc, dti, revol_util, total_acc, tot_cur_bal, days_since_earliest_cr
    ]], columns=list(norm_stats['means'].index))

    num_inputs_normalized = (num_inputs_df - norm_stats['means']) / norm_stats['stds']
    num_inputs_final = np.insert(num_inputs_normalized.values, 0, 0, axis=1)
    tensor_num = torch.tensor(num_inputs_final, dtype=torch.float32)

    # Realizar la Predicci√≥n
    with torch.no_grad():
        logits = nn_model(tensor_num, tensor_cat)
        probability = torch.sigmoid(logits).item()

    # Mostrar el Resultado
    st.markdown("---")
    prob_percent = probability * 100

    st.subheader("Resultado de la Evaluaci√≥n")
    if probability > 0.5:
        st.error(f"üî¥ Riesgo Alto (Probabilidad de Incumplimiento: {prob_percent:.2f}%)")
        st.warning("Recomendaci√≥n: Es probable que el cr√©dito sea rechazado.")
    else:
        st.success(f"üü¢ Riesgo Bajo (Probabilidad de Incumplimiento: {prob_percent:.2f}%)")
        st.info("Recomendaci√≥n: Es probable que el cr√©dito sea aprobado.")
        st.balloons()

    st.progress(probability)

    with st.expander("Ver detalles t√©cnicos de la predicci√≥n"):
        st.write(f"**Logit del modelo (salida cruda):** `{logits.item():.4f}`")
        st.write(f"**Probabilidad (Sigmoid):** `{probability:.4f}`")
        st.write("**Valores categ√≥ricos procesados (Post-EDA):**")
        st.json({
            "Antig√ºedad Laboral": processed_emp_length,
            "Tipo de Vivienda": processed_home_ownership,
            "Prop√≥sito": processed_purpose,
            "Morosidades": processed_delinq_2yrs,
            "Solicitudes": processed_inq_last_6mths,
            "Registros P√∫blicos": processed_pub_rec
        })
        st.write("**Tensor de entrada categ√≥rico (√≠ndices):**")
        st.write(tensor_cat)